<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Closure aur chai</title>
</head>
<body style="background-color: #313131;">
    <button id="orange">Orange</button>
    <button id="green">Green</button>
</body>

    <script>
    // function init() {
    //     let name = "Mozilla"; 
    //     function displayName() {
    //         console.log(name); 
    //     }
    //     displayName();
    // }
    // init();

    // function outer(){
    //     let username = "hitesh"
    //     console.log("OUTER", secret);
    //     function inner(){
    //         let secret = "my123"
    //         console.log("inner", username);
    //     }
    //     function innerTwo(){
    //         console.log("innerTwo", username);
    //         console.log(secret);
    //     }
    //     inner()
    //     innerTwo()

    // }
    // outer()
    // console.log("TOO OUTER", username);


    // function makeFunc() {
    //     const name = "Mozilla";
    //     function displayName() {
    //         console.log(name);
    //     }
    //     return displayName;
    // }

    // const myFunc = makeFunc();
    // myFunc();

    </script>
    <script>
        // document.getElementById("orange").onclick = function(){
        //     document.body.style.backgroundColor = `orange`
        // }
        // document.getElementById("green").onclick = function(){
        //     document.body.style.backgroundColor = `green`
        // }

        function clickHandler(color){
            // document.body.style.backgroundColor = `${color}`

            return function(){
                document.body.style.backgroundColor = `${color}`
            }
        }

        document.getElementById('orange').onclick = clickHandler("orange")
        document.getElementById('green').onclick = clickHandler("green")

    </script>
</html>

<!-- Lexical scope in layman terms help us to understand that the inner functions can take the variables defined in the outer/parent function but the parallel/sibling functions will not be able to access the variables defined in one of the parallel function! -->
<!-- Closure allows us to keep the lexical scope of a main function along, the context is not lost but is taken as whole as lexical scope, in simple terms lets say if the inside function has returned, so closure defines that it will also take along the lexical scope of its parent function too rather than just taking its(inner function) functional execution context! -->
<!-- A closure is a combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function's scope from an inner function even after the outer function has finished executing -->
<!-- Lexical scoping, also known as static scoping, is a way to resolve variable names in a programming language. In lexical scoping, the scope of a variable is determined by its position within the source code's lexical structure (i.e., where the variable is declared) rather than by the program's execution flow. This means that when a variable is referenced, the interpreter or compiler looks up its value based on the variable's location in the source code. -->